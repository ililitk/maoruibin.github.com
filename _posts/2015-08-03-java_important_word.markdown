---
layout: post
author: 咕咚
title:  "Java关键字之volatile"
description:  "描述信息"
categories: 技术
tags:  KeyWords Java
---
Java有众多关键字，volatile作为一个和同步相关的关键字，很少在自己的项目中使用，今天在看Handler源码时无意看到，顺便便了解了下。
记录以备后用。


volatile关键字 可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。

一般的，Java中设置变量的操作，除了long和double类型的变量，其余都是原子操作，也就是说，对于基本的变量设置操作没必要使用同步。

在JVM1.2之前，Java的内存模型，总是从主内存读取变量，就是说，变量只存在于内存的一个地方，但是随着JVM的成熟，读取内存的过程也做了相应的更改。

在当前的内存模型下，线程可以把变量在本地内存（比如机器的寄存器），而不是直接在内存读取，这个变化的原因，我猜测可能是下面的原因：
如果频繁的修改读取内存中的一个变量，可能效率比较低，在JVM1.2之后，做了优化，发现如果一个变量被频繁的读取修改，那么就把这个变量先放到本地寄存器，这个读取效率更高。每次直接去读寄存器中的数据。

但是，现在就出现一个问题，一个线程在主内存修改了变量的值，另一个线程在寄存器修改了这个变量的值，此时就出现了变量值不同步的问题，最终数据不一致。
这时，volatile关键字就出现了。


只要把变量声明为volatile，这就指示JVM，这个变量是不稳定的，只要成员变量发生变化，强迫线程将变化同步到主内存，一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。
Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。


总结：
volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互
使用volatile关键字，就表示着将屏蔽掉JVM对变量访问的优化，所以在效率上比较低，因此一定在必要时才使用此关键字。

### 摘抄

`point1` : Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存重新读取该成员的值，而且，当成员变量值发生变化时，强迫将变化的值重新写入共享内存，这样两个不同的线程在访问同一个共享变量的值时，始终看到的是同一个值。

`point2` : java语言规范指出：为了获取最佳的运行速度，允许线程保留共享变量的副本，当这个线程进入或者离开同步代码块时，才与共享成员变量进行比对，如果有变化再更新共享成员变量。这样当多个线程同时访问一个共享变量时，可能会存在值不同步的现象。


