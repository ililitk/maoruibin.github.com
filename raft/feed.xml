<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>咕咚</title>
    <description>有意义就是好好活，好好活就有意义。
</description>
    <link>http://maoruibin.github.io//</link>
    <atom:link href="http://maoruibin.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 21 Feb 2016 16:19:40 +0800</pubDate>
    <lastBuildDate>Sun, 21 Feb 2016 16:19:40 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>RxJava 在 AppPlus 中的应用</title>
        <description>&lt;p&gt;RxJava 已经出来很长一段时间了，国内也已经有很多公司在使用，与此同时，有不少优秀的开发者也不断的在开源社区分享自己对 RxJava
的使用理解，而且这个过程中也产出了不少优秀的 RxJava 资料。自己通过这些资料以及一些开源项目也在不断的学习 RxJava，
从一开始的 GankDaily 项目中蹒跚学步，到 AppPlus 中的大量实战，自己对 RxJava 的应用也变得熟练了起来，
这篇文章结合自己的实践，简单说说 RxJava 以及它在 AppPlus 这个项目中的应用。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;先说一些与技术无关的内容。&lt;/p&gt;

&lt;p&gt;其实关于 RxJava 的使用介绍文档，国内已经有很多非常优秀的文章，比如扔物线的 &lt;a href=&quot;http://gank.io/post/560e15be2dca930e00da1083&quot;&gt;给 Android 开发者的 RxJava 详解&lt;/a&gt;
以及 hi大头鬼hi 的&lt;a href=&quot;http://blog.csdn.net/lzyzsd/article/details/41833541&quot;&gt;深入浅出RxJava (译文)&lt;/a&gt;系列文章，都是非常不错的文章，自己把上面的文章至少读了两遍以上，
从中收获颇多，而且文章中已经把 RxJava 的很多要点写的很清楚了，尤其是扔物线的那篇。&lt;/p&gt;

&lt;p&gt;所以，如果想了解 RxJava 使用方法，推荐直接去看上面两位的博文，这篇文章主要是记录自己学习过程中的一些感悟、以及自己在 &lt;a href=&quot;https://github.com/maoruibin/AppPlus&quot;&gt;AppPlus&lt;/a&gt; 这个项目中的实践。&lt;/p&gt;

&lt;p&gt;关于自己为什么要写这篇，主要是因为在看了别人的文章后，觉得有必要记录一下自己的理解，毕竟，别人的文章是别人的理解，是人家自己的学习记录以及思考。
很多知识点只有经过自己的思考、应用、再思考、再理解才会变成自己的知识，
当然不排除那种只看一遍就能领会 RxJava 核心思想的牛人，反正自己不是，纸上得来终觉浅，所以自己在读完了上面的文章后把 RxJava 应用到了自己的项目 
&lt;a href=&quot;https://github.com/maoruibin/AppPlus&quot;&gt;AppPlus&lt;/a&gt; 中，并且决定在这里记录一些自己对 RxJava 的一些理解，用于加深对 RxJava 的认识理解。&lt;/p&gt;

&lt;h3 id=&quot;rxjava&quot;&gt;为什么要有 RxJava&lt;/h3&gt;

&lt;p&gt;RxJava 的核心在于 异步。他的出现主要方便简化原来复杂的异步逻辑处理，下面是扔物线举出的一个实例，一个数组中含有多个图片本地路径，现在要把他们显示在
一 ImageView 上，这是一个典型的异步过程。用传统的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Thread() {
    @Override
    public void run() {
        super.run();
        for (File folder : folders) {
            File[] files = folder.listFiles();
            for (File file : files) {
                if (file.getName().endsWith(&quot;.png&quot;)) {
                    final Bitmap bitmap = getBitmapFromFile(file);
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            imageCollectorView.addImage(bitmap);
                        }
                    });
                }
            }
        }
    }
}.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 RxJava 的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Observable.from(folders)
    .flatMap(new Func1&amp;lt;File, Observable&amp;lt;File&amp;gt;&amp;gt;() {
        @Override
        public Observable&amp;lt;File&amp;gt; call(File file) {
            return Observable.from(file.listFiles());
        }
    })
    .filter(new Func1&amp;lt;File, Boolean&amp;gt;() {
        @Override
        public Boolean call(File file) {
            return file.getName().endsWith(&quot;.png&quot;);
        }
    })
    .map(new Func1&amp;lt;File, Bitmap&amp;gt;() {
        @Override
        public Bitmap call(File file) {
            return getBitmapFromFile(file);
        }
    })
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Action1&amp;lt;Bitmap&amp;gt;() {
        @Override
        public void call(Bitmap bitmap) {
            imageCollectorView.addImage(bitmap);
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 RxJava 后的好处是程序结构变的清晰了，整个实现逻辑是流式风格，特别适合阅读，可以显著的提升代码的阅读性。
如果整个团队都使用 RxJava ,那么后续维护成本就会降低写，因为代码的阅读性得到了提高。&lt;/p&gt;

&lt;p&gt;有种面向过程编程的感觉啊~&lt;/p&gt;

&lt;h3 id=&quot;rxjava-&quot;&gt;RxJava 原理介绍&lt;/h3&gt;

&lt;p&gt;RxJava 的异步实现主要是通过一种可扩展的观察者模式得到的。RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;被观察者&lt;/code&gt;(Observable) 发出 &lt;code&gt;事件&lt;/code&gt;(Event) &lt;code&gt;观察者&lt;/code&gt;(Observer) &lt;code&gt;订阅&lt;/code&gt;(Subscribe)事件，当&lt;code&gt;被观察者&lt;/code&gt;发出事件，观察者则会接受消息事件。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简单使用&lt;/h3&gt;

&lt;p&gt;这里忽略如何引入 RxJava 的方式，具体可去 &lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt; 开源站点去获取。&lt;/p&gt;

&lt;p&gt;首先来看 AppPlus 中的一个应用场景，在首页，我们需要查询最近运行的程序列表，这很明显一个异步过程，符合 RxJava 的应用场景，
我们在工作线程去获取数据，获取数据完毕后，回到主线程完成界面更新。&lt;/p&gt;

&lt;p&gt;整个过程中， &lt;code&gt;被观察者&lt;/code&gt;是一个抽象的数据获取过程，而&lt;code&gt;观察者&lt;/code&gt;则是界面更新这个操作，在实际应用中，大多数情况下
被观察者和观察者都是这种抽象的概念。&lt;/p&gt;

&lt;p&gt;下面首先定义一个观察者，这段代码在 &lt;a href=&quot;https://github.com/maoruibin/AppPlus/blob/04a177710d4914469f68860e16c7105004f82021/app/src/main/java/com/gudong/appkit/ui/fragment/AppListFragment.java#L284-L284&quot;&gt;AppListFragment&lt;/a&gt;中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Subscriber&amp;lt;List&amp;lt;AppEntity&amp;gt;&amp;gt; subscriber = new Subscriber&amp;lt;List&amp;lt;AppEntity&amp;gt;&amp;gt;() {
    @Override
    public void onNext(List&amp;lt;AppEntity&amp;gt; appEntities) {
         setData(appEntities, mType);
    }

    @Override
    public void onCompleted() {
        loadingFinish();
    }

    @Override
    public void onError(Throwable throwable) {
        Log.d(tag, &quot;Error!&quot;);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个&lt;code&gt;观察者&lt;/code&gt; 等待 &lt;code&gt;被观察者&lt;/code&gt; 获取数据，&lt;code&gt;被观察者&lt;/code&gt;获取到数据后就会自动发布事件，然后自动调用到观察者中已经定义好的
回调方法，如上所示，调用 setData() 方法去更新界面，很简单的逻辑。&lt;/p&gt;

&lt;p&gt;那&lt;code&gt;被观察者&lt;/code&gt;如何定义，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Observable&amp;lt;List&amp;lt;AppEntity&amp;gt;&amp;gt; observable =  DataHelper.getRunningAppEntity(getActivity());
   
  /**
     * get the running app list info
     * @param ctx
     * @return
     */
    public static Observable&amp;lt;List&amp;lt;AppEntity&amp;gt;&amp;gt; getRunningAppEntity(final Context ctx) {
        return RxUtil.makeObservable(new Callable&amp;lt;List&amp;lt;AppEntity&amp;gt;&amp;gt;() {
            @Override
            public List&amp;lt;AppEntity&amp;gt; call() throws Exception {
                List&amp;lt;ActivityManager.RunningAppProcessInfo&amp;gt; runningList = ProcessManager.getRunningAppProcessInfo(ctx);
                List&amp;lt;AppEntity&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
                for (ActivityManager.RunningAppProcessInfo processInfo : runningList) {
                    String packageName = processInfo.processName;
                    if (isNotShowSelf(ctx, packageName)) continue;
                    AppEntity entity = DataHelper.getAppByPackageName(packageName);
                    if (entity == null) continue;
                    list.add(entity);
                }
                return list;
            }
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里牵扯到另一个问题，如何让自己的异步方法返回一个 Observable 对象，具体查看另一篇不错的译文 &lt;a href=&quot;http://www.devtf.cn/?p=734&quot;&gt;将数据库操作 RxJava 化的方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在观察者与被观察者都已经建立好了，按照之前的说法，现在只需要要通过 observable 的 subscribe 方法就可以将两者关联起来，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;observable.subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这里还有一个问题，我们写惯了 Android 的异步代码，都知道这样一个道理，获取数据等耗时操作要写在
工作线程中，以防止应用 ANR ，但是数据获取成功后，要更新界面，就需要到把这个操作放到主线程中去完成，通常我们使用 Handler 就可以方便的做到上述这点，
但是使用 RxJava 后我们怎么办，现在在被观察者和观察者中都没有看到任何和线程切换的操作，默认他们都应该是在主线程中运行。&lt;/p&gt;

&lt;p&gt;不出意外的话，执行上面的代码，程序应该会奔溃，因为获取最近运行的程序列表是一个耗时操作，把它刚在主线程明显是有问题的，那怎么办？&lt;/p&gt;

&lt;p&gt;这里不妨设想下，如果 RxJava 可以提供两个方法，一个用来控制&lt;code&gt;被观察者&lt;/code&gt;中逻辑代码的执行线程，另一个用来控制&lt;code&gt;观察者&lt;/code&gt;执行的线程该多好，那对我们程序员
来说不非常方便吗，写惯了以前的 Android 代码，我们对那些代码应该放在主线程、那些代码应该放在子线程已经非常清楚，所以如果 RxJava 可以提供这样的
线程控制 API 那一定是极好的。&lt;/p&gt;

&lt;p&gt;既然都这样设想了，RxJava 必然已经提供了这样的方法，否则我也不会设想，哈哈~下面就说说 RxJava 中的线程控制&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;线程控制&lt;/h3&gt;

&lt;p&gt;RXJava 使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制&lt;/p&gt;

&lt;p&gt;subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。&lt;/p&gt;

&lt;p&gt;observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。一般的我们用到的这里应该是主线程&lt;/p&gt;

&lt;p&gt;经过这个分析，修改上面的代码，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;observable
    // 指定了获取数据的操作（被观察者）发生在 io 线程
    .subscribeOn(Schedulers.io())
    // 指定了界面更新的操作 (观察者) 发生在 mainThread
    .observeOn(AndroidSchedulers.mainThread())
    // 观察者订阅数据获取这一事件
    .subscribe(subscriber);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于 Schedulers 内置的那几个线程可选项可查看扔物线博客 线程控制 —— Scheduler (一) 那一章节。&lt;/p&gt;

&lt;p&gt;到此为止，使用 RxJava 完成一个异步事件订阅就完成了。&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//technology/2016/01/21/RxJava_In_AppPlus.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//technology/2016/01/21/RxJava_In_AppPlus.html</guid>
        
        <category>Android</category>
        
        <category>RxJava</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>Android 过度绘制介绍及优化 Tip</title>
        <description>&lt;p&gt;Android 中的过度绘制是指同一个像素被绘制多次，从绘制性能角度讲，同一像素点被绘制的次数当然越少越好，这样有利于减轻 GPU 的工作压力，事实上，在具体开发过程中
，不可避免的可能会出现过度绘制，这里，Android 系统本身在开发者选项里已经提供了一个选项开关 Debug GPU overdraw(调试 GPU 过度绘制)，用于检测 App 的过度绘制，
只要打开这个开关，App 界面就会在不同的界面区域根据像素的绘制次数显示出不同的颜色，下面说说这几种颜色。&lt;/p&gt;

&lt;p&gt;关于过度绘制，也可以去查看官方的相关说明&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://developer.android.com/intl/zh-cn/tools/performance/debug-gpu-overdraw/index.html&quot;&gt;Debug GPU Overdraw Walkthrough&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;颜色说明&lt;/h3&gt;

&lt;p&gt;如果同一个像素点被绘制了两次，意味着过度绘制了一次，此时显示蓝色，大片的蓝色是一种比较理想的状态。&lt;/p&gt;

&lt;p&gt;如果同一个像素点被了绘制三次，意味着过度绘制了二次，此时显示绿色，如果界面中中等部分的绿色是可以接受的。&lt;/p&gt;

&lt;p&gt;如果同一个像素点被绘制了四次，意味着过度绘制了三次，此时显示浅红色，如果界面中有小范围的红色也是可以接受的。&lt;/p&gt;

&lt;p&gt;如果同一个像素点被了绘制五次或者更多（这个绘制的有点过分了啊！），意味着过度绘制了四次，此时显示暗红(GPU 发烫时的颜色)，
&lt;code&gt;This is wrong. Fix it.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面是一副官方关于颜色说明的图片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/over_draw_color_1.png&quot; style=&quot;width: 50%;margin: auto;&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Note:&lt;/code&gt; 如果只被绘制了一次，那么不显示任何指示颜色，即透明。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;实例&lt;/h3&gt;

&lt;p&gt;上面说了几种不同状态对应的颜色，下面结合代码，我们看看在 App 中过度绘制具体如何表现。&lt;/p&gt;

&lt;p&gt;新建应用 OverdrawDemo ，没有任何逻辑代码，直接看 Layout 文件，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;me.gudong.overdrawdemo.MainActivity&quot;&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后打开 开发者选项的过度绘制选项，效果如下，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/over_draw_color_2.png&quot; style=&quot;width: 50%;margin: auto;&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;请先忽略 Toolbar 相关的颜色。这里可以看到在内容区域，是没有过度绘制的指示颜色，因为这片区域确实只被绘制了一次。&lt;/p&gt;

&lt;p&gt;此时试想一下，如果为根布局的 LinearLayout 设置背景色，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android:background=“#f4f4f4&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时的界面会是怎样&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/over_draw_color_3.png&quot; style=&quot;width: 50%;margin: auto;&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;因为这个 Activity 默认已经用主题指定背景绘制了一次内容区域(DecorView)，此时在绘制 LinearLayout 时，因为指定 &lt;code&gt;android:background=“#f4f4f4&quot;&lt;/code&gt;的缘故，这片区域的
 像素点必然会被绘制两次，所以此时的内容区域就会显示为蓝色。&lt;/p&gt;

&lt;p&gt;同样的道理，绿色、浅红色、暗红色都是根据同一像素点绘制次数的不同，而显示出来。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;为什么要研究过度绘制&lt;/h3&gt;

&lt;p&gt;对一个 App 来说，它运行时要不停的根据用户的操作去绘制不同的界面，绘制界面主要由 GPU 控制，如果一个界面过度绘制比较严重，大部分界面区域都被
绘制了3、4次甚至更多，那么就会浪费掉 GPU 的很多性能，这对于一个追求有良好体验 App 的开发者肯定是不允许的。&lt;/p&gt;

&lt;p&gt;尽管大部分情况下，App 的过度绘制不可避免，但是在开发中，我们还是应该尽可能去减少过度绘制。&lt;/p&gt;

&lt;p&gt;从一定程度上，减少过度绘制会有利于提高 App 的流畅度。目前我们用到的主流 App 都有过度绘制的优化，包括微博微信，他们的首页在过度绘制方面做的都很不错，
但是，也有很多 App 在这方面不够重视亦或者是优化力度不大，如下图对比了一些优化的比较好的 App 和一些没有优化的或者优化不够出色的 App。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/over_draw_good_one.png&quot; style=&quot;width: 50%;margin: auto;float:left;&quot; /&gt;
&lt;img src=&quot;/assets/over_draw_bad_one.png&quot; style=&quot;width: 50%;margin: auto;float:right;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;微信 VS 回家吃饭&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/over_draw_good_two.png&quot; style=&quot;width: 50%;margin: auto;float:left;&quot; /&gt;
&lt;img src=&quot;/assets/over_draw_bad_two.png&quot; style=&quot;width: 50%;margin: auto;float:right;&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;微博 VS Keep&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tips&quot;&gt;避免过度绘制的 Tips&lt;/h3&gt;
&lt;p&gt;既然过度绘制是不好的，那么我们在开发中就应该尽量去减少过渡绘制，这里结合自己网上看到的一些优化 tip ,整理一下。&lt;/p&gt;

&lt;p&gt;1、对于我们开发中的用到的 View ，如果对他设置背景颜色没有意义的，那么我们就应该不要随便去给他设置背景色。&lt;/p&gt;

&lt;p&gt;待补充…&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考文章&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://developer.android.com/intl/zh-cn/tools/performance/debug-gpu-overdraw/index.html&quot;&gt;Debug GPU Overdraw Walkthrough&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/145fc61011cd&quot;&gt;Android性能优化之如何避免Overdraw&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 15 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//technology/2016/01/15/over_draw_color_introduce.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//technology/2016/01/15/over_draw_color_introduce.html</guid>
        
        <category>Android</category>
        
        <category>Performance</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>Android性能优化典范 - 第1季 阅读笔记</title>
        <description>&lt;p&gt;该文章是自己在阅读 Android性能优化典范-第一季 时的读书笔记，Android性能优化典范主要讲了Android的渲染机制、内存和GC以及电量优化方面相关的内容，因为内容比较庞杂，加上一些知识点需要花心思去理解，所以在阅读的时候，顺便记录一下自己的阅读理解。&lt;/p&gt;

&lt;p&gt;原文 &lt;a href=&quot;http://hukai.me/android-performance-patterns/&quot;&gt;Android性能优化典范-第一季&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;笔记条目&lt;/h2&gt;

&lt;p&gt;1、Android 系统每隔 16ms 发出 VSYNC 信号，触发硬件对 UI 的渲染。&lt;/p&gt;

&lt;p&gt;2、1秒 = 1000ms 所以基于上面的规则，每一秒 UI 应该渲染 1000/16 = 60 (次)，也就是我们经常看到的 60hz 这个值，表示一秒内刷新屏幕的次数，用术语讲 这叫刷新率(Refresh Rate)。&lt;/p&gt;

&lt;p&gt;3、刷新率这个值取决于硬件的固定参数，一般的这个值为60fps,原因在于人眼与大脑无法感知超过60fps的界面更新。&lt;/p&gt;

&lt;p&gt;4、帧率是区别于刷新率的另一个概念，他代表每一秒GPU绘制操作的帧数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Note&lt;/code&gt;:两者的区别在于刷新率表示屏幕会按照这个频率去不停的刷新屏幕，至于屏幕上显示什么他控制不了，帧率表示GPU(图形处理器)一秒内绘制的次数，他俩前者负责按刷新率不停刷新界面，后者负责按帧率去不停绘制界面。&lt;/p&gt;

&lt;p&gt;5、刷新率和帧率需要结合在一起工作，才能让视图内容呈现在屏幕。&lt;/p&gt;

&lt;p&gt;6、GPU获取图形数据并绘制，硬件负责把GPU生成的视图数据拿出来显示在屏幕上，这个过程一遍遍的在我们的手机中发生着。&lt;/p&gt;

&lt;p&gt;如果屏幕刷新率和GPU帧率一致，那肯定是极好的，GPU每隔特定时间准备好视图数据。然后相应的
，因为屏幕刷新率跟帧率一致，所以，此时此刻屏幕正好也刷新界面，视图正常显示。&lt;/p&gt;

&lt;p&gt;但是大多数情况下，他俩的步调可能不一致，所以会出现错位的情况&lt;/p&gt;

&lt;p&gt;此时，GPU 那边准备了数据，但是屏幕这边缺不能及时的显示出来。&lt;/p&gt;

&lt;p&gt;7、界面渲染双缓冲技术&lt;/p&gt;

&lt;p&gt;一般我们在绘制UI的时候，都会采用一种称为“双缓冲”的技术。双缓冲意味着要使用两个缓冲区（SharedBufferStack中），其中一个称为Front Buffer，另外一个称为Back Buffer。UI总是先在Back Buffer中绘制，然后再和Front Buffer交换，渲染到显示设备中。理想情况下，这样一个刷新会在16ms内完成（60FPS）&lt;/p&gt;

&lt;p&gt;更多详情可参考 &lt;a href=&quot;http://djt.qq.com/article/view/987?ADTAG=email.InnerAD.weekly.20131216&quot;&gt;http://djt.qq.com/article/view/987?ADTAG=email.InnerAD.weekly.20131216&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8、任何时候，只要 View 中的绘制内容发生变化，都会重新执行创建 DisplayList 、渲染 DisplayList&lt;/p&gt;

&lt;p&gt;9、Android 中的内存模型分三级（这里的内存应该指的是堆内存）分别为 Young Generation、Old Generation、Permanent(常驻) Generation，也就是说 Android 虚拟机中的堆内存假如有125M,那么这125M会被指定为不同的类型，具体怎么指定，不用细究，他可以对每一块区域设置一个变量，用于指示这个区域是属于哪一级，这个纯属个人臆想，但说这么多，就是为了说明一个事实，Android 堆内存 那块空间会被划分为三种不同的类型，Young、Old、Permanent。&lt;/p&gt;

&lt;p&gt;这里每个区域肯定一个具体的大小值，具体大小的分配就是 JVM 的事了， Old 区、Permanent 区的大小要大于 Young 区。&lt;/p&gt;

&lt;p&gt;10、对内存区域分级的意义，先不看官方介绍，个人推测一下也不难知道，这样做就是为了更好的利用内存空间这么如此宝贵的地方。被划分成不同的区域后，我们每次 new
一个新对象时，毫无疑问，新对象分配的空间应该在 Young Genration 内存区域内。&lt;/p&gt;

&lt;p&gt;11、该说说垃圾回收了。当我们的程序不断的运行、不断的创建对象，Young 区的空间肯定有被用完的时候，此时 JVM 检测到 内存空间不够用，就会启动 GC ，执行垃圾回收，此时他很可能会对 Young 区的一些值做一些判断，看他们是不是被频繁的使用，如果是，他应该会把这部分内存空间标记为 Old。同样的道理，Old 区的对象也可能被转移到 Permanent 去，总之 JVM 这样做就是为了提高对象创建的效率。&lt;/p&gt;

&lt;p&gt;垃圾回收会把 Young 区中无用的对象给清理掉。&lt;/p&gt;

&lt;p&gt;12、关于上述的推测，这里是胡凯博文中的原话，对照理解下：&lt;/p&gt;

&lt;p&gt;Android里面是一个三级Generation的内存模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。&lt;/p&gt;

&lt;p&gt;每一个级别的内存区域都有固定的大小，此后不断有新的对象被分配到此区域，当这些对象总的大小快达到这一级别内存区域的阀值时，会触发GC的操作，以便腾出空间来存放其他新的对象。&lt;/p&gt;

&lt;p&gt;13、内存泄露问题。胡凯博文写的很清楚明白，直接引用胡凯的原文&lt;/p&gt;

&lt;p&gt;内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。&lt;/p&gt;

&lt;p&gt;内存泄露为什么会导致性能问题，上面的这段话很精辟的指出来了。就是因为泄露的对象会沉积在内存区，随着泄露的对象越来越多，JVM 周期性的 GC 后发现内存空间依旧满满的，此时就会发生大家常说的内存溢出问题了。&lt;/p&gt;

&lt;p&gt;其实垃圾回收器(GC)在很努力的回收内存区中的无用对象，但是每次扫描却发现 那些泄露的对象一直被一些或者的对象所持有，所以内存泄露问题，一定在开发中需要重视。&lt;/p&gt;

&lt;p&gt;14、每次 GC 的时候，其他所有线程都是暂停状态，也就是说 GC操作会暂停其他任务。&lt;/p&gt;

&lt;h2 id=&quot;tip&quot;&gt;开发 Tip&lt;/h2&gt;

&lt;p&gt;以上是自己在阅读《Android性能优化典范》时的笔记，感谢作者可以把视频内容转化为更加容易理解的文章。
但是任何好文章，阅读完应该可以给读者一些指导，这篇文章中讲了很多概念以及原理，下面就针对文章，总结一些开发过程中应该遵循的一些建议，以期让自己的 App 具有更好的性能。&lt;/p&gt;

&lt;p&gt;1、避免在 for 循环中给对象分配内存，直白一点就是说 不要在 for 循环中 new 对象，最好可以移动到 for 之前。&lt;/p&gt;

&lt;p&gt;2、避免在自定义 View 时，在 onDraw 方法中执行太复杂的逻辑操作。&lt;/p&gt;

&lt;p&gt;3、避免在 onDraw 方法中 创建对象，因为在界面绘制时，该方法可能会被大量的重复执行，这样会导致一瞬间产生大量的对象，从而导致堆空间中瞬间产生大量无用对象，从而触发 JVM 的 GC 操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Note&lt;/code&gt;：一些情况下，无法避免在 onDraw 方法中创建对象，那么此时为了优化性能，可以采取对象池的策略，手动缓存已创建的对象，并加以复用，从而降低性能损失。但是使用此方法，需要注意一点，应该及时的手动清理对象池，否则可能会引起更加严重的内存问题。&lt;/p&gt;

&lt;p&gt;4、开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。所以我们的布局能简单则简单。&lt;/p&gt;

&lt;p&gt;5、考虑到过渡绘制，我们在写布局 layout 时，不应该随意的去为一些 View 设置 background，例如，当我们的根布局已经设置过一次背景色，那么子view默认的背景色就是它了，所以对于一些子 View ，如果它跟根布局背景颜色一致，那么该 View 就无需再设置背景色了，另外一些情况可能需要设置 selector，此时默认背景可以设置为 透明色。&lt;/p&gt;

&lt;p&gt;6、对于电量优化，我们应该减少唤醒屏幕的次数以及持续时间，使用 WeakLock 处理唤醒问题。&lt;/p&gt;

&lt;p&gt;7、对一些非必须马上执行的操作，可以等待手机处于充电状态或者电量充足时再执行。&lt;/p&gt;

&lt;p&gt;8、对一些零散的网络请求，可以打包一次操作，避免过多的无线信号引起的电量消耗。&lt;/p&gt;

</description>
        <pubDate>Wed, 13 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//note/2016/01/13/android-performance-patterns-first-note.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//note/2016/01/13/android-performance-patterns-first-note.html</guid>
        
        <category>Android</category>
        
        <category>Performance</category>
        
        
        <category>note</category>
        
      </item>
    
      <item>
        <title>《火星救援》有感</title>
        <description>&lt;p&gt;忙里偷闲，在 &lt;a href=&quot;http://www.acfun.tv/&quot;&gt;Acfun&lt;/a&gt; 这个网站看了一部电影 - 火星救援，看之前，对这个电影没什么特别大的期待，
不过因为主演是马特达蒙，所以今天就选择了这部电影。&lt;/p&gt;

&lt;p&gt;第一次看他的电影是 &lt;a href=&quot;http://www.acfun.tv/v/ac306986&quot;&gt;谍影重重&lt;/a&gt;，自己也是从这部电影开始，喜欢上他。&lt;/p&gt;

&lt;p&gt;依旧记得大学时，连续三个周末，看完了谍影重重系列，每周一部，不敢贪多，当时只觉得两个小时太短了！&lt;/p&gt;

&lt;p&gt;当时因为太喜欢，特意还裁剪下其中的剧照（恩，当时应该用的是QQ影音自带的截图工具截的图），不过当时自己还没有的博客，所以现在我觉得，有必要把当时的截屏都放在这里了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;追忆谍影重重&lt;/h2&gt;

&lt;p&gt;截下的每个画面，都是自己觉得特别有意义的镜头。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_01.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;很喜欢这种大场景拍摄，法国凯旋门&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_02.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;跟女主角被迫分开&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_03.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;离别总是那么纠结&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_04.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;超喜欢大场景，应该是谍影2了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_05.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;好美&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_06.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;俄罗斯火车站&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_07.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;忘了，这是什么场景了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_08.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;&quot;踩石&quot; 老巢&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/dycc_09.jpg&quot; alt=&quot;dycc&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;女主角被追杀了，伯恩好难过&lt;/p&gt;

&lt;p&gt;容我稍许回味下当时的感觉，恩，那年我大二，那年我记得看了好多电影。《未知死亡》《窃听风暴》都挺不错的。那是一个美好的一年。&lt;/p&gt;

&lt;p&gt;关于火星救援，一开始看了剧照，只看到主演一个人穿着宇航服，行走在火星表面。觉得电影应该比较平淡无常，但事实上，这部电影好几次都戳中泪点，让人为之动容。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;剧情&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mars_felling_7.jpg&quot; alt=&quot;start&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一场风暴和一个意外让 Mark(电影主演)被迫留在火影，因此 Mark 也负伤在身，昏迷醒来后，进入自己的工作驻地后，开始为自己疗伤。忍着
剧痛为自己封伤口，但为了生存，他咬牙完成了一切。&lt;/p&gt;

&lt;p&gt;于此同时，另一端的地球正在为他举行葬礼，Mark 身体恢复后开始清点自己的食物、水，因为等到下次 NASA 来火星只能是4年后，所以他必须
解决食物的问题，然后他自己开始种土豆，找土壤、找水，他一刻也没闲着，用自己的双手在不断的为延续自己的生命做着拼搏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mars_felling_2.jpg&quot; alt=&quot;土豆&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;Mark 在火星种土豆&lt;/p&gt;

&lt;p&gt;电影中他为自己多了很多事，所有一切都是为了生命，看着他不停的奔波劳作，让我想到，一个深陷如此孤独的世界中的人，在没有丧失自己
存活的希望后，还能如此的为自己明天而不断折腾，是多么不容易的一件事。&lt;/p&gt;

&lt;p&gt;恩，Mark 是一个很乐观的人，能在这样一个与世隔绝的地方还能不断折腾的人，如果对自己不乐观、为未来不乐观，很难想象他能存活这么久。&lt;/p&gt;

&lt;p&gt;每个人每天每月每年都会面对很多事，需要自己处理，总归都要面对，我觉得保持乐观是一个良好的习惯。向 Mark 一样，即使有时会遇到一些很糟糕
的情况， Mark 后来的辛苦种植的土豆因为一个意外原因，全部被冻死，这对于他来说，就像农民伯伯辛苦一年后庄稼颗粒无收，
这会是一种怎么样的绝望。&lt;/p&gt;

&lt;p&gt;他跟大多数人一样，Shit! 爆了一句粗口，但是并没有陷入当前的糟糕状态，而是更加积极努力的去思考解决方式。&lt;/p&gt;

&lt;p&gt;人生总是这样，&lt;code&gt;人生不如意十之八九&lt;/code&gt;，对待如意的时候，我们应该&lt;code&gt;人生得意须尽欢&lt;/code&gt;,但是对待不如意的时候，我们不能&lt;code&gt;今宵有酒今宵醉&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我相信，保持乐观会让我们得到的更多，同时遇到问题不抱怨，及时找原因，总结教训，这才是最正确的做法。&lt;/p&gt;

&lt;p&gt;电影中有几个地方很让我感动。&lt;/p&gt;

&lt;p&gt;当他跟地面取得联系的时候,他要离开他的火星车的时候，以及他们他队长在太空中拥抱的时候。&lt;/p&gt;

&lt;p&gt;患难中的希望更加让人觉得来之不易，所以让他跟地面可以联系时，他很兴奋，因为自己再也不是一个人了。&lt;/p&gt;

&lt;p&gt;陪伴了他500多天的火星车，最终自己要离开它，就像《荒岛漂流》中鲁滨逊跟自己的排球告别时一样，火星车之与 Mark ，就像排球之于鲁滨逊。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mars_felling_4.jpg&quot; alt=&quot;thinking&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;Mark 在思考对火星车说点什么&lt;/p&gt;

&lt;p&gt;在描述告别的这段剧情时，导演特意用了整部电影中少有的比较抒情的音乐作为背景音乐，很感人的情景，突然觉得在火星呆了这么久，居然对这里的一切
有点恋恋不舍了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mars_felling_3.jpg&quot; alt=&quot;say-goodbye&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;Mark 跟自己的火星车告别&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mars_felling_5.jpg&quot; alt=&quot;thinking&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;Mark 离开火星车&lt;/p&gt;

&lt;p&gt;当他拥抱到队长时，这是他经过了所有的努力后，得到的应有的回报。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mars_felling_6.jpg&quot; alt=&quot;success&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一些人看上去总是很幸运的背后，往往是常人看不到的努力与付出。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//private/2015/12/27/mars_felling.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//private/2015/12/27/mars_felling.html</guid>
        
        <category>电影</category>
        
        
        <category>private</category>
        
      </item>
    
      <item>
        <title>再见 2015 ，你好 2016 ~</title>
        <description>&lt;p&gt;这篇文章是我的2015年终总结。去年就曾想过写一篇自己的2014年终总结，后来想过几天再写，然后一晃已经是2015年末了，
时间就是这么快。我觉得今年一定要抽时间总结下，在梳理得与失的同时，也是对自己一年里，做的所有事的一个回忆和反思。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;这一年&lt;/h2&gt;

&lt;p&gt;这一年发生了很多事，不论生活方面，还是工作方面，都经历了比去年更多的事。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;生活方面&lt;/h3&gt;

&lt;p&gt;其实，这一年应该从媳妇跟我一起坐上来北京的列车开始。到北京后媳妇用了一个多月的时间找工作，在这一个多月里，我过了到北京后，迄今为止应该算是最舒适的一段日子。&lt;/p&gt;

&lt;p&gt;每天下班后回家，都会觉得是一件很特别让人期待的事，因为我不知道她又给我准备了什么好吃的，尽管一开始房间挺小挺拥挤，但却很温暖。&lt;/p&gt;

&lt;p&gt;后来因为经常一起做饭的缘故，自己炒菜水平在今年也大有长进，这也算是2015的一个收获。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;工作方面&lt;/h3&gt;

&lt;p&gt;公司在年初时，内部就有了一些比较大的变动，裁员，高管离职(说的好像公司很大的样子)…好在我们移动开发团队比较稳定。&lt;/p&gt;

&lt;p&gt;老大一直都是自己很钦佩的那种技术人员，热衷技术，属于那种在技术上很执着的人，他一直说，他的主要任务就是让我们更 happy 的写代码，
我们的开发的基础一直都是在他写的框架之上。&lt;/p&gt;

&lt;p&gt;关于这个框架，这里简单说下，是一种 MVP + AOP 模式的架构，项目做到了充分的解耦，对异步请求做了巧妙的控制。
要知道这是他14年年初写的，那时 MVP 开发模式远没有现在这样被大家所熟知，我知道 MVP 这个模式一开始也是从这里得知。&lt;/p&gt;

&lt;p&gt;关于这个框架未来的发展，我们在组内会议时也讨论过，打算在 15 年开源，这是个美好的愿望。
但是后来因为这样那样的原因最终未能如愿以偿。算是一个遗憾。&lt;/p&gt;

&lt;p&gt;自己是从去年14年加入公司，加入公司后，老大一直帮助自己理解和使用框架，自己也深深被这种高效率的开发模式所吸引，后来很长一段时间内，都是
不停的做公司项目的功能迭代开发。&lt;/p&gt;

&lt;p&gt;相比去年，今年我开始着手一些模块的开发，开始自己一个人去负责开发优化模块，这段时间里，自己分别优化了项目中比较大的几个模块，其中的筛选模块是一个比较
复杂的模块，最终经过自己三次版本迭代达到了自己心目中的理想状态。&lt;/p&gt;

&lt;p&gt;但后来被证明，自己因为大量使用枚举，以至于在后续维护时，出现了一些问题，而且在Android中大量使用枚举，也不是Android所推崇的，甚至 Android 的技术文档
有这样的建议&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enums often require more than twice as much memory as static constants.You should strictly avoid using enums on Android.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到后来，年中的时候，老大离职了，尽管不舍，但是这却也是互联网公司中最普遍的现象。&lt;/p&gt;

&lt;p&gt;同时，这个时间段，随着公司业务的变化，我们的项目变得多了起来，新项目是在老项目基础上修改开发，
但还要加入各种新功能，并且由于老项目是14年初的项目，加上新业务的一些变化，同时定了交付时间，
那段时间(9-10月份)各种问题频出，其实是很煎熬的。&lt;/p&gt;

&lt;p&gt;同时那段时间，公司又经历了一次人员流动潮。那段时间真叫动荡。后来顶着压力，硬是把项目按时交接了，
记得很清楚，有一天加了一个通宵的班，加到自己流鼻血！！！&lt;/p&gt;

&lt;p&gt;然后第二天早晨回到家，当我喝到媳妇给熬得粥的时候，突然觉得好感动~&lt;/p&gt;

&lt;p&gt;这次的人员变动，涉及到了我们 Android 团队，有两个同事相继离职，同时 Android 团队的负责人被也调去负责服务端，因为服务端负责人也已经离职（好混乱的局面），
所以自己被提为 Android 负责人，因为 Android 团队人员偏少，所以接下来的一段时间，需要自己面试招聘新同学。&lt;/p&gt;

&lt;p&gt;面试持续了大概一个月时间。面试了10多人，水平层次不齐，在面试的同时我感受到了一些技术人员的浮躁，和一些泡沫的存在，
个人水平、工作经历和期望薪资不匹配的有很多，这种现象也许这存在于整个互联网公司。&lt;/p&gt;

&lt;p&gt;但自己作为一个技术人员，如果为技术圈长远健康的发展考虑的话，我还是希望泡沫早点破灭的好，希望更多的人去重视个人技术的成长积累，而不要好高骛远
的盲目追求高工资。&lt;/p&gt;

&lt;p&gt;最终经过内推，团队终于招到一个比较合适的同学。&lt;/p&gt;

&lt;p&gt;再后来，公司决定使用 Web + Native 的方式进行开发，算是一个比较大的调整，经过一个多月的时间，经过两个版本的迭代，最终搞定了最新的开发模式对应的框架。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;稍作感悟&lt;/h2&gt;

&lt;p&gt;自己写之前也没有细想，写了之后，发现工作中具体而微的事挺多的，一年真是可以发生好多事，人走人来，项目变化，等等…&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;一些有意义的事&lt;/h3&gt;

&lt;p&gt;尽管工作中遇到的事挺多的，但是公司有一点一直特别好，不加班(严格点说是极少加班)，所以使得自己的业余时间还是比较多的，周末从来都是双休。&lt;/p&gt;

&lt;p&gt;自己在业余的时间也确实做了不少事(相比去年)。&lt;/p&gt;

&lt;p&gt;我一直是个闲不住的人，喜欢倒腾，对新东西总是充满好奇心，庆幸的是，自己的好奇心到现在也没减。&lt;/p&gt;

&lt;p&gt;一般的，工作之余的娱乐活动，除了我会去打球其余的时候，我更愿意自己倒腾点东西玩玩，
相比往年，很明显今年做了跟多的有意思的事，下面简单罗列下。&lt;/p&gt;

&lt;h3 id=&quot;mac&quot;&gt;买了MAC&lt;/h3&gt;

&lt;p&gt;这算是今年买过的最贵的一个物品，当时花了12000多，硬是找朋友从香港代购了一个15寸的低配MAC，其实我想买高配，但是当时正好没货，但现在
到手的后来发现也没差到哪里。&lt;/p&gt;

&lt;p&gt;当时也是看到圈里好多同学都建议买买买，我也就没忍住，现在想想，这也算是2015年做得最正确的选择之一啊，否则此时此刻，我也不可能在飞机上听着音乐写博客！&lt;/p&gt;

&lt;p&gt;现在也是越来越喜欢它啦~哈哈！&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;去了泰山&lt;/h3&gt;

&lt;p&gt;一场说走就走的旅行，这是自己想了很久的一件事，但是从大学到现在，自己也没有真真的迈出过哪一步。&lt;/p&gt;

&lt;p&gt;今年11月初，终于，利用一个周末的时间，去了一次济南，自己选择济南，一是因为离北京比较近，二是因为我一个小学同学在济南读研，去济南顺便也是看他！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/tanshan_4.jpg&quot; alt=&quot;pos4&quot; title=&quot;tanshan&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;青梅竹马的好基友&lt;/p&gt;

&lt;p&gt;周五晚上的火车，周六早晨就到济南，简单跟天哥（小学同学）吃过早饭，自己就迫不及待去了千佛山，自己一直很喜欢山川，千佛山不怎么高，没多久自己就到了山顶，
后来自己一个人听着音乐穿梭在密林中，真真切切的感受到自由的存在，一种久违的感觉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/tanshan_1.jpg&quot; alt=&quot;pos5&quot; title=&quot;tanshan&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;行走在小路上&lt;/p&gt;

&lt;p&gt;后来接着去了趵突泉、大明湖，最让我影响深刻的还是周日去的泰山。&lt;/p&gt;

&lt;p&gt;我喜欢山，泰山作为五岳之首，我对它更是向往有加，从自己开始登泰山之前，就按奈不住自己激动的心情。仿佛自己像是实现了一个伟大的梦想一样。那种开心，
不知怎么解释，也许是自己太久没有迈出这一步。&lt;/p&gt;

&lt;p&gt;后来到山顶后，我们尽情拍照纪念，毫不保留的把自己知道的 pos 摆个够。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/tanshan_5.jpg&quot; alt=&quot;pos3&quot; title=&quot;tanshan&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;那就是最终的泰山顶&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/tanshan_2.jpg&quot; alt=&quot;pos1&quot; title=&quot;tanshan&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;会当凌绝顶，一览众山小&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/tanshan_3.jpg&quot; alt=&quot;pos2&quot; title=&quot;tanshan&quot; /&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:center&quot;&gt;故作眺望，哈哈~&lt;/p&gt;

&lt;p&gt;总之这是一个特别有意义的开始，也许以后去旅行，再也不会像这次这么激动，但我希望自己可以保持这种去旅游的冲动以及激情。&lt;/p&gt;

&lt;h3 id=&quot;jekyll--github-&quot;&gt;使用 Jekyll + Github 搭建自己的个人博客&lt;/h3&gt;

&lt;p&gt;以前经常在网上搜所一些技术信息时，经常能看非常精美的个人 blog 站点，以前只知道有 WordPress，但是今年偶然看到某篇博客的评论
里提到了 Jekyll 这个博客工具，然后自己一搜，发现还真是个好东西，然后自己马上动工做了自己的博客站点，就是现在这个。&lt;/p&gt;

&lt;p&gt;博客主要用于记录自己工作中遇到的问题，以及一些技术思考或者介绍，另外还可能有一些个人感悟等日志记录。总之不想把它定义为纯粹的技术博客，
首先自己技术好没有到达那种传道授业的境界，另外还是想随意一点，不想太拘束了。&lt;/p&gt;

&lt;p&gt;说道博客，其实，一开始自己选择的模板并不是现在看到的样子，对那个老模板，自己曾花了不少时间去优化，
但是最终的结果还是不够让人满意，直到10月24（程序员节）那天，偶然发现一个很不错的 Jekyll 主题，也就是现在这套，当时一看到首页那种大气，简单的设计，
就认定它了。&lt;/p&gt;

&lt;p&gt;然后自己花了一个下午，给博客换主题，最终的结果让我很满意。关于换主题的过程，其实不是那么的顺利，那天（10月24）自己写了一篇日志
用于记录我的一天，其中就有换主题的一部分介绍！&lt;a href=&quot;/private/2015/10/24/1024.html&quot;&gt;我的1024这天&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;后来自己在博客里写过几篇不错的文章，其中文章《&lt;a href=&quot;/技术/2015/11/10/android_m_permission.html&quot;&gt;在Android 6.0 设备上动态获取权限&lt;/a&gt;》曾被Android开发技术周报收录过一次。挺开心。&lt;/p&gt;

&lt;h3 id=&quot;appplus&quot;&gt;开源了 AppPlus&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2015_summary_appplus.png&quot; alt=&quot;appplus&quot; title=&quot;appplus&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AppPlus 是自己做的一个手机 App 管理软件，&lt;a href=&quot;technology/2015/12/21/reason-for-appplus.html&quot;&gt;为什么开发了 AppPlus&lt;/a&gt;，
按照我一直以来的习惯，这个 App 力争简单易用，一开始为了学习主题切换，曾加入过换肤等功能，后来觉得臃肿，最终还是去掉了。&lt;/p&gt;

&lt;p&gt;后来App被发布到四个主流的Android市场，其中在小米商店，目前已经有10万+的下载量，我始终相信，简单就是生产力！对产品对代码都是如此。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/maoruibin/AppPlus&quot;&gt;开源地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://app.mi.com/detail/104777&quot;&gt;小米市场下载&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;参与干货集中营干货的收集&lt;/h3&gt;
&lt;p&gt;年中的时候，偶然注意到了一个 &lt;a href=&quot;http://gank.io&quot;&gt;干货集中营&lt;/a&gt; 这个技术站点，每个工作日更新技术干货信息，
并对信息进行了分类，后来我觉得可以增加一个 APP 分类模块，每天推荐一些比较有意思、好玩的项目，最好开源，不分Android iOS,&lt;/p&gt;

&lt;p&gt;后来跟网站主编 &lt;a href=&quot;https://github.com/daimajia&quot;&gt;@代码家&lt;/a&gt; 联系并说明自己想法，家家爽快的答应(merge)，然后自己也成了干货集中营的小编，每天为所有订阅读者挑选
优质开源 App 项目。&lt;/p&gt;

&lt;p&gt;参与干货搜集中过程中，同时也认识了很多朋友，大家都热爱开源，喜欢交流，很开心能认识这么多人。&lt;/p&gt;

&lt;h3 id=&quot;gankdaily&quot;&gt;为干货集中营开发客户端 GankDaily&lt;/h3&gt;

&lt;p&gt;在我为干货集中营开发这个客户端之前，干货集中营已经有&lt;a href=&quot;http://gank.io/download&quot;&gt;三个Android客户端&lt;/a&gt;，用于展示干货信息，其实 drakeet 同学&lt;a href=&quot;https://github.com/drakeet/Meizhi&quot;&gt;妹纸&lt;/a&gt;是一个非常有逼格的
项目，自己在看了项目代码后，也是受益匪浅，项目使用很多新潮的技术。&lt;/p&gt;

&lt;p&gt;后来自己抱着学习的目的，开始模仿妹纸项目 试图打造一个自己的干货客户端。&lt;/p&gt;

&lt;p&gt;尽管原项目代码已经很精简，但是视图层跟业务逻辑没分开，加上自己正好想实践下那段时间研究的 MVP 模式，所以自己开始重构项目。&lt;/p&gt;

&lt;p&gt;后来自己不仅在代码层面上进行大量的修改，将原有的项目结构完全使用 MVP 模式实现，在界面排版上也做了相应的改动。最中界面如下所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gank_mvp_introduce.png&quot; alt=&quot;mvp&quot; title=&quot;mvp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;后来项目发布后，因为自己的疏忽大意，跟 drakeet 同学造成了一点小误会。因为自己对开源协议的不重视和不够了解，导致自己侵犯了原作者的
 权利，不过后来经过交流，小风波就过去了，于此同时，自己也对开源协议有了一定的了解。&lt;a href=&quot;/thinking/2015/11/24/copy-right-meizhi.html&quot;&gt;开源协议小风波&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;相关链接&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/maoruibin/GankDaily&quot;&gt;开源地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/technology/2015/11/23/gank_mvp_introduce.html&quot;&gt;MVP 模式在 GankDaily 中的应用&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;涨了很多粉丝&lt;/h3&gt;

&lt;p&gt;不论 &lt;a href=&quot;https://github.com/maoruibin/&quot;&gt;Github&lt;/a&gt;还是&lt;a href=&quot;http://weibo.com/u/1874136301&quot;&gt;微博&lt;/a&gt;都涨了不少粉丝。&lt;/p&gt;

&lt;p&gt;记得年初 Github 只有7个粉丝，都是认识的同事，但截止现在已经 120 个粉丝，尽管这不是自己一直以来参与开源社区的动力，但是看到这么多人
的认可，自己还是挺开心的。&lt;/p&gt;

&lt;p&gt;同时通过在开源社区的活动，让我更加认识到自己的渺小，在这里领域里，有太多牛人，自己要做的就是脚踏实地，朝着自己的方向，不停的前进，
保持一个初学者心态。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;坚持打球&lt;/h3&gt;

&lt;p&gt;从大学毕业开始，自己保持了最久的习惯莫过于此。自己是一个标准的篮球粉丝，特爱打球，工作后，即使工作再忙，周末的时间自己总会
抽空去附近的球场打球。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2015_summary_basketball.png&quot; alt=&quot;basketball&quot; title=&quot;北理工球场&quot; /&gt;&lt;/p&gt;
&lt;p style=&quot;text-align:center&quot;&gt;北理工的球场~&lt;/p&gt;

&lt;p&gt;今年亦如此，因为租住房间的附近有一个公园，公园中有一个球场，所以每周末，自己总会抽空去打球。每次打的大汗淋淋，出汗的感觉真好。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;结婚生子&lt;/h3&gt;

&lt;p&gt;今年，我终于跟自己的高中同学完成了爱情长跑的升华。&lt;/p&gt;

&lt;p&gt;我们结婚了，一路走来，峰回路转，柳暗花明，终于，我们还是没有输给时间和距离。&lt;/p&gt;

&lt;p&gt;并且，最让人开心的算是我们有了爱情的结晶，我们的儿子顺利出生。对于这个可爱的小生命，我和媳妇都无比疼爱，有了他，我们的生活变得不一样。&lt;/p&gt;

&lt;p&gt;同时，也让我知道了自己的父母，在养育我们长大的这段旅程上，有多么不易。&lt;/p&gt;

&lt;p&gt;生命就像一场回溯。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;2015 不足遗憾&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对一些技术了解不够深入，在能基本使用的基础上，没有去深入理解一些知识点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;算法数据结构,待补&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术类书籍看的比较多，但综合书籍看的少&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行力欠缺&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;还是太年轻了，容易轻信别人。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-11&quot;&gt;2016 希望计划&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;有自己的房子（加油啊~）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;凡事预则立，不预则废，继续用好 &lt;a href=&quot;https://www.wunderlist.com/zh/&quot;&gt;Wunderlist&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;翻译自己认为不错的国外文章（要求不高，明年必须翻译一篇）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;练字(练完一个本子)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小心驶得万年船&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看书（不多，16年能看两本课外书就是成功）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Google Play 上架应用(一个就行)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;学会Node.js(给自己的App搭建一个后台)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;继续学习PS(可以做ICON)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;坚持写博客(每月至少一篇)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拍照记事，每天一记。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;保持好奇心。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;愿激情常在…&lt;/p&gt;

&lt;p&gt;更新于 2016/02/14&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//private/2015/12/22/my_2015_life.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//private/2015/12/22/my_2015_life.html</guid>
        
        <category>年终总结</category>
        
        
        <category>private</category>
        
      </item>
    
      <item>
        <title>为什么开发了 AppPlus</title>
        <description>&lt;p&gt;AppPlus 是自己今年七月份开始做的一个小产品，它是一个主要用Android用户间传送Apk文件、管理手机应用的工具软件。&lt;/p&gt;

&lt;p&gt;目前已开源，&lt;a href=&quot;https://github.com/maoruibin/AppPlus&quot;&gt;开源地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;为什么要做这个软件&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;一、我想用最少的步骤打开最近运行的应用详情界面&lt;/h3&gt;

&lt;p&gt;因为是开发者的缘故，我经常需要清理应用缓存数据，一般的做法时，找到系统设置-&amp;gt;应用管理-&amp;gt;找到对应的应用-&amp;gt;打开应用详情界面，然后清理数据，
 而且手机应用那么多，找应用也是个很麻烦的事，这个过程至少需要30秒左右的时间不止。&lt;/p&gt;

&lt;p&gt;不过在这一点上，MIUI 做的不错，点击桌面菜单，显示出最近运行的应用列表，长按即可打开应用详情，在其他 ROM 上你只能去系统设置中找，好麻烦。&lt;/p&gt;

&lt;p&gt;当然在使用 AndroidStudio 进行开发的过程中，AS 插件库里也已经有插件(&lt;a href=&quot;https://github.com/pbreault/adb-idea&quot;&gt;adb-idea&lt;/a&gt;)
 可以做到一键清数据，但是他只能针对调试中的应用，如果我想清理其他 APP 的缓存，他就不行了。&lt;/p&gt;

&lt;p&gt;所以我需要一个 APP 能帮助我显示出最近打开的应用，并且提供一个按钮可以打开应用详情界面。&lt;/p&gt;

&lt;p&gt;Update:最近刚看到一个有用的Api可以方便的清除应用的缓存数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* Permits an application to erase its own data from disk. 
* This is equivalent to the user choosing to clear the app&#39;s
* data from within the device settings UI.It erases all dynamic
* data associated with the app -- its private data and data in its
* private area on external storage -- but does not remove the
* installed application itself, nor any OBB files.
*/
ActivityManager.clearApplicationUserData()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法由 &lt;code&gt;ActivityManager&lt;/code&gt; 提供，可一键清理app产生的用户数据。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;二、我想方便快捷的导出手机中已安装应用的安装包&lt;/h3&gt;

&lt;p&gt;一些情况下，开发者需要一些应用的安装包，比如自己以前因为做手机卫士没有合适的图标，所以只好找到360手机卫士的安装包，然后解压缩，从而使用
 现成的素材，谁叫自己不会 PS 呢，很多时候下载软件好办，Android市场那么多，只要自己想找，下载软件还是不难的，但是拿到对应的软件安装包好像不是那么容易。
 但事实上，只要在 Android 手机中安装了应用，这个应用的安装包就已经存在于手机了。&lt;/p&gt;

&lt;p&gt;这里说明一个事实，安装在我们手机中的每一个的 APP ，在手机中都存在他对应的安装包文件，不像Windows程序，
 当你下载好 QQ 的安装包 QQ.exe,点击安装后，除非你人为保存安装包，系统是不会给你把安装包存下来的，Android 不一样，他会把应用的安装包
 都存在本地。&lt;/p&gt;

&lt;p&gt;所以在 Android 手机上，只要知道了应用的安装包路径，导出还是挺容易的，不就是复制到一个自己指定的目录吗。这也不是什么高深的技术。&lt;/p&gt;

&lt;p&gt;另外，尽管市场上已经有很多可以提供导出安装包功能的软件，我为什么还要自己做一个?&lt;/p&gt;

&lt;p&gt;因为，他们都做得太 low 了。糟点太多。举个例子说明下。&lt;/p&gt;

&lt;p&gt;自己曾经用过一个安装包导出软件，首页用一个列表展示所有已安装的应用，然后只要点击一个 item ，安装包就会导出。&lt;/p&gt;

&lt;p&gt;导出成功后会『友好』的弹出一个 Toast ，提示安装包已导出，顺便在 Toast 中指明导出的路径，如下所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/appplus_about_1.png&quot; style=&quot;width: 50%;margin: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是因为 Toast 的弹出时间太短了，以至于我一次很难记住安装包到底被导出到那个路径下了，所以一般你需要再次导出一次，然后
 特意去注意 Toast 上提示的路径，你才可以记住导出的路径。It’s too bad !&lt;/p&gt;

&lt;p&gt;当然，我在 AppPlus 中在实现导出 Apk 这一功能时，这个问题肯定得到了很好的解决。具体怎么解决，可以自己体验下试试。&lt;a href=&quot;http://fir.im/appplus&quot;&gt;立即下载&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;三、不喜欢广告。&lt;/h3&gt;

&lt;p&gt;用户体验这么差，怎么好意思加广告！&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;四、学习&lt;/h3&gt;

&lt;p&gt;一方面学习 GoogleIO 2015大会新放出的最新的一些组件，另一方方面是学习实践 MaterialDesign，因为自己太喜欢 MD 的设计风格了，
  没办法，尽管目前国内 MD 的设计风格 还没有流行开，但是自己就是这么喜欢。&lt;/p&gt;

&lt;p&gt;综上所述，就是自己开发这个 App 的所有原因。&lt;/p&gt;

</description>
        <pubDate>Mon, 21 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//technology/2015/12/21/reason-for-appplus.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//technology/2015/12/21/reason-for-appplus.html</guid>
        
        <category>Android</category>
        
        <category>App</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>利用 Gradle Task 查看远程依赖库的本地存储路径</title>
        <description>&lt;p&gt;这篇文章主要分享一个主题，如何在 AndroidStudio 中利用 gradle 查看自己项目中引入的三方依赖库的本地缓存路径。相信一些同学会对这个
话题感兴趣的。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;问题&lt;/h3&gt;

&lt;p&gt;自从使用 AndroidStudio + Gradle 开始项目开发，我们已经用到了很多 gradle 带来的特性，比如要在项目中使用三方 Lib ，
我们再也不需要像 eclipse 时代，需要我们手动下载对应的 jar 包，从 gradle 开始，我们只要在build.gradle 加入三方lib的
dependencies 路径，然后同步，lib就自动下载到本地了。&lt;/p&gt;

&lt;p&gt;例如，我们要在自己的项目中引用 square 公司的网络框架 OkHttp ，只需要在 build.gradle
文件中加一行依赖路径即可，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;compile &#39;com.squareup.okhttp:okhttp:2.5.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入之后，同步，我们就可以使用 okhttp 提供的各种 API ，很简单的导入方式。&lt;/p&gt;

&lt;p&gt;但是时间久了，我就愈发想知道，gradle到底把lib给存到什么地方了，
今天搜了一圈，找到一个靠谱的方法，特意分享下，也不是什么技术点，只是解决我心中的一个疑问而已。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;答案&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; dependencies{
     .....
 }
 
 //显示依赖包的存储路径   
 task showMeCache &amp;lt;&amp;lt; {
     configurations.compile.each { println it }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上所示，只需要在 build.gradle 文件中，增加如上所示的一个 task ,然后打开 AndroidStudio 自带的 Terminal 窗口，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gradle showMeCache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可看到所有依赖的对应路径，&lt;/p&gt;

&lt;p&gt;Note : 因为 gradle 文件顺序执行的特点，这个任务应该定义在&lt;code&gt;dependencies&lt;/code&gt;节点之下。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;结果&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;:app:showMeCache
/Users/mao/workpace/person/AppPlus/app/libs/lite-orm-1.7.0.jar
/Users/mao/workpace/person/AppPlus/app/libs/umeng-update-v2.6.0.1.jar
/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/appcompat-v7/23.1.1/appcompat-v7-23.1.1.aar
/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/design/23.1.1/design-23.1.1.aar
/Users/mao/.gradle/caches/modules-2/files-2.1/com.jenzz/materialpreference/1.3/def38f1784f5f789b10ed388e385f7857e765405/materialpreference-1.3.aar
/Users/mao/.gradle/caches/modules-2/files-2.1/com.readystatesoftware.systembartint/systembartint/1.0.3/de4f7404e2f58d8f6e83cb1e85d0c2d6c2987287/systembartint-1.0.3.jar
/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/gridlayout-v7/22.2.0/gridlayout-v7-22.2.0.aar
/Users/mao/.gradle/caches/modules-2/files-2.1/com.umeng.analytics/analytics/5.6.4/76fed6d2233b958f0c1d589aa366785e0ab5c8f1/analytics-5.6.4.jar
/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/percent/23.1.0/percent-23.1.0.aar
/Users/mao/.gradle/caches/modules-2/files-2.1/com.jaredrummler/android-processes/1.0.2/704bbcb3f6d25c5da24b3e0199b178520ad7ca7e/android-processes-1.0.2.aar
/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/support-v4/23.1.1/support-v4-23.1.1.aar
/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/recyclerview-v7/23.1.1/recyclerview-v7-23.1.1.aar
/Users/mao/Downloads/android/sdk/extras/android/m2repository/com/android/support/support-annotations/23.1.1/support-annotations-23.1.1.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enjoy it.&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//technology/2015/12/20/watch_dependencies_path.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//technology/2015/12/20/watch_dependencies_path.html</guid>
        
        <category>Gradle</category>
        
        <category>Task</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>开源协议小风波</title>
        <description>&lt;p&gt;今天无意间在做项目的过程中，因为没有遵守开源协议，导致了一个小误会，尽管已经跟drakeet同学致歉，但后来还是觉得有必要把事情再梳理一遍，让更多的开发者注重一下开源协议。&lt;/p&gt;

&lt;p&gt;一开始在微博看到了@drakeet 同学开源了一个项目，叫 &lt;a href=&quot;https://github.com/drakeet/Meizhi&quot;&gt;MeiZhi&lt;/a&gt;，一个干货集中营的 unofficial 客户端，客户端用于在手机端更好的显示技术干货信息，因为自己平时也比较关注技术干货，自己也就开始使用。&lt;/p&gt;

&lt;p&gt;整个客户端一开始都是drakeet一个人设计开发完成，其实对于程序员来说，写代码、开发往往是最轻松的事，最难的往往是设计，最终drakeet的干货客户端给人的视觉操作体验整体还是非常不错的，其中有很多细节，完成的很不错。&lt;/p&gt;

&lt;p&gt;后来自己阅读了源码，更是对代码钦佩不已。项目中使用了RxJava Retrofit以及JAVA8新特性lambda ，整个项目代码很简洁，很优雅。&lt;/p&gt;

&lt;p&gt;因为自己之前没有接触RxJava等知识，所以自己想仿照项目，自己动手实践一边RxJava的语法内容，以及lambda，因为我相信实践出真知，后来自己就new了一个项目，开始使用干货集中营的api进行开发，开始动手练习&lt;/p&gt;

&lt;p&gt;后来在写页面的时候，觉得把所有的数据获取逻辑写在Activity中其实不好，这样Activity会显得臃肿，正巧那段时间，大家在讨论MVP，所以自己就干脆使用MVP来做项目，毕竟是小项目，重构起来还是挺方便，重构很顺利。&lt;/p&gt;

&lt;p&gt;在重构完成后，我觉得自己已经不是在单纯的练习一些语法知识了，发现自己其实在做一个客户端。因为我想突出干货内容，所以后来就把干货首页改为了当天的干货信息，也就是下面的样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/licence_1.jpeg&quot; style=&quot;width: 50%;margin: auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时为了突出时间，还对图片做了亮度的调节，所以图片看上去暗点，这样时间也就显得更清楚一点。&lt;/p&gt;

&lt;p&gt;后来代码被自己review了好几次，然后尝试发beta版，在一些开发者朋友的反馈下，自己又改了一些细节，然后就把应用发布了，同时代码也公布在github。&lt;/p&gt;

&lt;p&gt;其实一开始，我是知道原项目是基于一个开源协议发布的，因为自己在看代码的过程中也多次看到drakeet在代码中的协议内容，包括在MeiZhi的Readme文件中也有这样的字样&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/licence_2.jpeg&quot; alt=&quot;license&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是自己没有花精力去像思考代码结构那样思考开源协议，然后就把代码公布，这也许是很多开发者不注意的问题。&lt;/p&gt;

&lt;p&gt;对于我们而言很多时候都会把精力集中在具体的代码，而对于代码之外的一些东西往往会很容易忽略。&lt;/p&gt;

&lt;p&gt;通过这件事提醒我们，作为开发者应该了解一些开源协议的问题，开源协议有很多，但是常用的就那些。&lt;/p&gt;

&lt;p&gt;自己事后也开始找一些开源协议相关的资料,&lt;a href=&quot;http://kymjs.com/manager/2015/11/21/01/&quot;&gt;聊聊Apache开源协议&lt;/a&gt; @kymjs张涛&lt;/p&gt;

&lt;p&gt;此外，drakeet同学也提供一张有用的图片，如下所示，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/licence_3.jpeg&quot; alt=&quot;license&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于开源协议如果有更好的资料欢迎补充，自己最近也会多多学习并了解这方面！&lt;/p&gt;

&lt;p&gt;再次感谢drakeet同学的及时指正，我的项目GankDaily也会尽快按照协议进行修正！不过最近因为自己的时间问题可能无法及时更新代码，可能需要过段时间才可以，不过开源协议这块，以后自己一定会注意到！&lt;/p&gt;

&lt;p&gt;当然说这么多，也希望大家可以在以后的工作开发中，注意到这个问题的存在，让我们一起对开源协议保持敬畏并了解学习使用它。&lt;/p&gt;

&lt;p&gt;附：文中出现的一些链接&lt;/p&gt;

&lt;p&gt;干货集中营 &lt;a href=&quot;http://gank.io/&quot;&gt;http://gank.io/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;妹纸 &lt;a href=&quot;https://github.com/drakeet/Meizhi&quot;&gt;https://github.com/drakeet/Meizhi&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GankDaily &lt;a href=&quot;https://github.com/maoruibin/GankDaily&quot;&gt;https://github.com/maoruibin/GankDaily&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;聊聊Apache开源协议&lt;a href=&quot;http://kymjs.com/manager/2015/11/21/01/&quot;&gt;http://kymjs.com/manager/2015/11/21/01/&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 24 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//thinking/2015/11/24/copy-right-meizhi.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//thinking/2015/11/24/copy-right-meizhi.html</guid>
        
        <category>Licence</category>
        
        
        <category>thinking</category>
        
      </item>
    
      <item>
        <title> MVP 模式在 GankDaily 中的应用</title>
        <description>&lt;p&gt;最近完成了一个干货客户端 &lt;a href=&quot;https://github.com/maoruibin/GankDaily&quot;&gt;GankDaily&lt;/a&gt; ，
一个基于&lt;a href=&quot;http://gank.io&quot;&gt;干货集中营&lt;/a&gt;的手机客户端，整个客户端借鉴 drakeet 的&lt;a href=&quot;https://github.com/drakeet/Meizhi&quot;&gt;妹纸&lt;/a&gt;应用。但是在原项目的基础上，
自己使用 MVP 模式对项目进行重构，让代码结构进一步解耦，使业务逻辑和视图表现层相分离，从而让代码逻辑变得更简单，
以下就整理了自己在重构项目过程中对 MVP 这种模式的理解以及项目中如何实施 MVP 的模式。&lt;/p&gt;

&lt;h3 id=&quot;mvp&quot;&gt;关于MVP&lt;/h3&gt;

&lt;p&gt;MVP 是 Module-Presenter-View的缩写，翻译过来就是模型-控制器-视图，是一种流行的开发架构模式。他主张让 Presenter 控制所有的业务逻辑，
让 View 层做具体的界面更新，Module 专门负责数据获取等操作。&lt;/p&gt;

&lt;p&gt;通常我们写惯了 Android 项目，一般一个 Activity 中可能对应很多数据交互，比如这个干货客户端首页，只要一进入首页，它需要获取当天的干货数据。
滑动到底部需要加载更多数据，除此之外还可能有一些其他的业务逻辑比如检查版本信息等。一般的，这些操作全部放在 Activity 中没有任何问题的，
这样做一点不妨碍你完成所有的功能。而且市面上确实有不少项目真是这么做的，最近跟一些朋友聊天，也说过他负责的项目就是这么干的，一个 Activity 6000
多行代码，简直是灾难~&lt;/p&gt;

&lt;p&gt;不过自己一开始写代码时，确实也是这样写的（囧~），记得曾经写过一个详情展示页，代码写了2000多行，当时觉得还挺自豪(呵呵~)，一个类2000多行呢，现在想想也是觉得
Too Young Too Simple .&lt;/p&gt;

&lt;p&gt;按照 MVP 的定义，我们应该把所有的业务逻辑操作都写在 Presenter 层，而 View 层(View 层一般由 Activity、Fragment充当)他们主要做一些更新界面、
向 Presenter 层发送请求的操作。Module 层则主要负责具体的数据获取操作。他们的具体关系可以看下面这张图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gank_mvp_1.jpg&quot; alt=&quot;mvp&quot; title=&quot;mvp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由图可以清楚的看到，Presenter 处在一个中心位置，View 层向 Presenter 发送请求，Presenter 自己接受请求，但是自己不具体执行请求，而是将
具体的事情交给 Module 去处理， 利用 Module 层请求完毕后，Presenter 再把具体的结果通过某种方式响应在 View 层。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;一个例子&lt;/h4&gt;

&lt;p&gt;上面说的有点抽象，其实这个过程可以理解的更加形象一点。打个比喻，把 P 理解为自己的脑袋，V 理解为右手 M 理解为 左手,然后你就站在那里，
假设左右手是不能直接沟通，左右手分别通过左胳膊和右胳膊与脑袋联系。&lt;/p&gt;

&lt;p&gt;现在 V(右手)需要100块钱进行消费，但是钱却存储在 M(左手)里，这时 V(右手)通过右胳膊告诉P(脑袋)，”脑袋，我需要100块钱，快给我。”，脑袋
得到这个命令后，因为自己不管钱，所以只得去请求 M (左手),P（脑袋）通过左胳膊告诉 M(左手),说自己需要100块钱，
M(左手)知道 P 需要钱，所以就慷慨的给钱,谁叫他是老大呢，此时 P 顺利拿到钱后，自己对钱稍微做一些验证操作，发现钱没问题，然后就把钱给了 V（右手），
此时为了安全起见，P (脑袋)需要调用一下 V(右手) 提供的一个握拳方法，以便及时的攥住钱，防止遗失，假设这个方法就叫 hold吧，P 调用 V(右手)的hold方法
后，右手在拿到钱的同时，就立即攥紧了钱，这样钱就不容易被别人拿走了。&lt;/p&gt;

&lt;p&gt;到这里，整个一次完整的数据交互(左手取钱)、界面更新(右手攥钱)过程就结束了，M 自始至终也没有跟 V 发生任何直接关系，它甚至不知道 V 的存在。P 则在
最中央的位置负责协调数据、操作View。他从左手拿钱，然后交给右手。当然还可以更多复杂的操作，但是整个 MVP 的大体结构就是这样。&lt;/p&gt;

&lt;p&gt;如果这个比喻觉得不清楚，那么你可以直接去看鸿洋之前写的一篇博客，用一个登录示例讲解 MVP ，讲的很清楚。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/46596109&quot;&gt;浅谈 MVP in Android&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;几个疑问&lt;/h4&gt;

&lt;p&gt;到这里可能会有几个疑问，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在 View(Activity、Fragment)层中怎么去调用 Presenter 中的方法？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个简单，在View初始化时，new 一个 Presenter 实例不就对了吗，确实可行，我目前也是这样做的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Presenter 怎么去控制 View 中的界面逻辑？具体点就是，上面的头部最后怎么调用右手的 hold() 方法？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里需要通过让 View 层通过实现特定 View 接口，每一个 View 类，也就是每一个 Activity 对应实现一个抽象的接口，也就是说在写每个 Activity 时，首先把具体的
 View 操作动作提取为一个接口，让 View 实现，让后想办法把这个接口的实例传递到 Presenter 实例中即可，这里可能稍微有点模糊，但是通过
 下面具体的代码，你可能就更清楚了。&lt;/p&gt;

&lt;h2 id=&quot;mvp-&quot;&gt;MVP 实践&lt;/h2&gt;

&lt;p&gt;可以先看看主界面。如下图，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gank_mvp_introduce.png&quot; alt=&quot;mvp&quot; title=&quot;mvp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主界面 MainActivity 显示的是当天的干货信息，下拉可刷新，滑动到底部可以加载更多，进入主界面还需要去检查版本信息，
如果发现是新版本，好需要弹出一个 Dialog 显示更新日志。大概的业务也就这些，然后我们把所有的业务逻辑都写在 MainPresenter 中，
代码如下，部分代码省略，如果想看全部代码，点击&lt;a href=&quot;https://github.com/maoruibin/GankDaily/blob/master/app/src/main/java/com/gudong/gankio/presenter/MainPresenter.java#L32-32&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void getData(final Date date) {
        mCurrentDate = date;
        mGuDong.getGankData(year, month, day)
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Subscriber&amp;lt;List&amp;lt;Gank&amp;gt;&amp;gt;() {
                    @Override
                    public void onCompleted() {
                        // after get data complete, need put off time one day
                        mCurrentDate = new Date(date.getTime()-DAY_OF_MILLISECOND);
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(List&amp;lt;Gank&amp;gt; list) {
                        // some day the data will be return empty like sunday, so we need get after day data
                        if (list.isEmpty()) {
                            getData(new Date(date.getTime()-DAY_OF_MILLISECOND));
                        } else {
                            mCountOfGetMoreDataEmpty = 0;
                            mView.fillData(list);
                        }
                        mView.getDataFinish();
                    }
                });
    }

    public void checkAutoUpdateByUmeng() {
        if(mContext.getIntent().getSerializableExtra(&quot;BUNDLE_GANK&quot;) == null){
            UmengUpdateAgent.setUpdateCheckConfig(BuildConfig.DEBUG);
            //check update even in 2g/3g/4g condition
            UmengUpdateAgent.setUpdateOnlyWifi(false);
            UmengUpdateAgent.update(mContext);
        }
    }

    //check version info ,if the version info has changed,we need pop a dialog to show change log info
    public void checkVersionInfo() {
        String currentVersion = AndroidUtils.getAppVersion(mContext);
        String localVersionName = AndroidUtils.getLocalVersion(mContext);
        if (!localVersionName.equals(currentVersion)) {
            mView.showChangeLogInfo(&quot;changelog.html&quot;);
            AndroidUtils.setCurrentVersion(mContext, currentVersion);
        }
    }
 
 
    /**
     * @return
     */
    public boolean shouldRefillData(){
        return !hasLoadMoreData;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面可以看到，获取数据的方法 getData(Date date)接受一个 date 参数，调用者 MainActivity 只需要在某个地方调用这个方法，并传递当前的
日期，就可以获取到当前所有的干货数据。到这，View 请求 Presenter 完成。下面具体执行数据请求就是另外的模块了。&lt;/p&gt;

&lt;p&gt;这里从具体代码看，可以发现，数据请求是通过 Rxjava + Retrofit 实现，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public void getData(final Date date) {
        mCurrentDate = date;
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        int year = calendar.get(Calendar.YEAR);
        int month = calendar.get(Calendar.MONTH)+1;
        int day = calendar.get(Calendar.DAY_OF_MONTH);
        //获取到 年 月 日 三个参数 ，准备传递给具体的方法。
        mGuDong.getGankData(year, month, day)
                .observeOn(AndroidSchedulers.mainThread())
                .map(new Func1&amp;lt;GankData, GankData.Result&amp;gt;() {
                    @Override
                    public GankData.Result call(GankData gankData) {
                        return gankData.results;
                    }
                })
                .map(new Func1&amp;lt;GankData.Result, List&amp;lt;Gank&amp;gt;&amp;gt;() {
                    @Override
                    public List&amp;lt;Gank&amp;gt; call(GankData.Result result) {
                        return addAllResults(result);
                    }
                })
                .subscribe(new Subscriber&amp;lt;List&amp;lt;Gank&amp;gt;&amp;gt;() {
                    @Override
                    public void onCompleted() {
                        // 获取数据完毕，将日期推迟到下一天 为获取更多数据做准备
                        mCurrentDate = new Date(date.getTime()-DAY_OF_MILLISECOND);
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(List&amp;lt;Gank&amp;gt; list) {
                        // 如果有一天数据为空，则继续获取下一天的数据
                        if (list.isEmpty()) {
                            getData(new Date(date.getTime()-DAY_OF_MILLISECOND));
                        } else {
                            //更新主界面数据
                            mCountOfGetMoreDataEmpty = 0;
                            mView.fillData(list);
                        }
                        mView.getDataFinish();
                    }
                });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 onNext 方法中，我们获取到了最终的数据，此时 Presenter 需要通知 View 更新界面，所以这里有了如下的调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onNext(List&amp;lt;Gank&amp;gt; list) {
    // 如果有一天数据为空，则继续获取下一天的数据
    if (list.isEmpty()) {
        getData(new Date(date.getTime()-DAY_OF_MILLISECOND));
    } else {
        //更新主界面数据
        mCountOfGetMoreDataEmpty = 0;
        mView.fillData(list);
    }
    mView.getDataFinish();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里通过 mView 这个实例 的fillData 方法去更新主界面。那么 mView 是一个什么变量呢，最终你会发现，他是一个 IMainView 接口的实例，可以看看
这个接口是怎么定义的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IMainView&amp;lt;T extends Soul&amp;gt;  extends ISwipeRefreshView {
    /**
     * load data successfully
     * @param data
     */
    void fillData(List&amp;lt;T&amp;gt; data);

    /**
     * append data to history list(load more)
     * @param data
     */
    void appendMoreDataToView(List&amp;lt;T&amp;gt; data);

    /**
     * no more data for show and this condition is hard to appear,it need you scroll main view long time
     * I think it has no body do it like this ,even though，I deal this condition also, In case someone does it.
     */
    void hasNoMoreData();

    /**
     * show change log info in a dialog
     * @param assetFileName the name of local html file like &quot;changelog.html&quot;
     */
    void showChangeLogInfo(String assetFileName);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现这个接口中确实存在一个 fillData 方法，所以上面使用 mView 调用 fillData 是可行的。&lt;/p&gt;

&lt;p&gt;那如果 MainPresenter 都可以调用 IMainView 的 fillData()方法来更新 MainActivity, 哪MainActivity 就和 IMainView 有必然的关系，
一个是类一个是接口，还能会有什么关系呢，这里 MainActivity 实现了 IMainView 这个接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MainActivity extends BaseSwipeRefreshActivity&amp;lt;MainPresenter&amp;gt; implements IMainView&amp;lt;Gank&amp;gt;,MainListAdapter.IClickMainItem {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然 MainActivity 实现了 IMainView 接口，那他必然实现对应的方法 fillData() ,如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void fillData(List&amp;lt;Gank&amp;gt; data) {
    mAdapter.updateWithClear(data);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，实现很简单，就是更新一下 Adapter 就 OK，Activity 中再也看不到任务获取数据的代码。&lt;/p&gt;

&lt;p&gt;到这里，让我们看看 MainPresenter 是在 MainActivity 的什么地方实例化的。这里因为每个 Activity 都是继承自 BaseActivity ，而且每个
Activity 必须有一个 Presenter ,所以我在 BaseActivity 中已经事先定义了一个 BasePresenter 的实例 mPresenter，同时给 BaseActivity 设置一个
抽象方法 initPresenter()。这个方法将会在BaseActivity onCreate 时执行到。代码如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class BaseActivity&amp;lt;P extends BasePresenter&amp;gt; extends AppCompatActivity {
    @Bind(R.id.toolbar)
    protected Toolbar mToolbar;
    /**
     * the presenter of this Activity
     */
    protected P mPresenter;

    /**
     * TODO use Dagger2 instance Presenter
     */
    protected abstract void initPresenter();
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(getLayout());
        ButterKnife.bind(this);
        initPresenter();
        checkPresenterIsNull();
        initToolBar();
    }
    
    private void checkPresenterIsNull(){
       if(mPresenter == null){
           throw new IllegalStateException(&quot;please init mPresenter in initPresenter() method &quot;);
       }
     } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置抽象方法的目的就是强制每个继承自 BaseActivity 的Activity类 都必须实现这个方法，并实例化 BasePresenter；&lt;/p&gt;

&lt;p&gt;如果不实例化 mPresenter，可以看到在 onCreate 中对 mPresenter 是否已经设置值做了 checkPresenterIsNull() 处理,只要发现 mPresenter 为 null
这里就会报错。&lt;/p&gt;

&lt;p&gt;MainActivity 继承自 BaseActivity ，所以它实现了 initPresenter() 方法。&lt;/p&gt;

&lt;p&gt;MainActivity中 initPresenter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    protected void initPresenter() {
        mPresenter = new MainPresenter(this, this);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里可以到 MainPresenter 的构造函数传递了两个参数。可以查看 MainPresenter 的构造方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public MainPresenter(Activity context, IMainView view) {
        super(context, view);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它直接调用自己父类 BasePresenter 的构造方法，这里可以看看 BasePresenter 类，很简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BasePresenter&amp;lt;GV extends IBaseView&amp;gt; {

    protected GV mView;
    
    protected Activity mContext;

    public static final GuDong mGuDong = MainFactory.getGuDongInstance();

    public BasePresenter(Activity context, GV view) {
        mContext = context;
        mView = view;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这里的两个参数分别是 Activity 和 IBaseView 的实例，IBaseView 是所有抽象 View 接口的父接口(目前是一个空接口)，
IMainView继承自IBaseView。&lt;/p&gt;

&lt;p&gt;这里就可以看到 其实每个 Presenter 中都有一个 IBaseView 的实例，只要在 Activity 实例化了 Presenter 实例，那么对应的IBaseView
实例其实也已经传递到了 Presenter 中，这样只要是界面更新的操作，我们就可以方便的调用 IBaseView 中的接口了。
再看一下 MainPresenter 中 的 onNext 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void onNext(List&amp;lt;Gank&amp;gt; list) {
    // 如果有一天数据为空，则继续获取下一天的数据
    if (list.isEmpty()) {
        getData(new Date(date.getTime()-DAY_OF_MILLISECOND));
    } else {
        //更新主界面数据
        mCountOfGetMoreDataEmpty = 0;
        mView.fillData(list);
    }
    mView.getDataFinish();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时 mView 调用 fillData()方法，应该已经清楚了吧。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;至此，MVP 大概就说完了，可以看看项目接口，也许会看到更清楚一点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/gank_mvp_3.jpeg&quot; alt=&quot;mvp&quot; title=&quot;mvp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此外，还用到了一些泛型的知识点，用来约束Base类的类型，大家有看着不明白的地方，可以留言。&lt;/p&gt;

</description>
        <pubDate>Mon, 23 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//technology/2015/11/23/gank_mvp_introduce.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//technology/2015/11/23/gank_mvp_introduce.html</guid>
        
        <category>Android</category>
        
        <category>App</category>
        
        
        <category>technology</category>
        
      </item>
    
      <item>
        <title>Android热修复技术链接收集</title>
        <description>&lt;p&gt;最近在社区看到很多关于Android热修复相关的技术文章以及开源项目，这里就对最近看到的文章、开源项目做个简单的整理，方便查阅。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;热修复准备&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;amp;mid=400118620&amp;amp;idx=1&amp;amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;amp;scene=1&amp;amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect&quot;&gt;安卓App热补丁动态修复技术介绍&lt;/a&gt;   QQ空间团队&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://my.oschina.net/853294317/blog/308583&quot;&gt;Android dex分包方案&lt;/a&gt; 开源中国&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;原理分析&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/49883661&quot;&gt;Android 热补丁动态修复框架小结&lt;/a&gt; 鸿洋_&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lzyzsd/article/details/49843581&quot;&gt;Android热更新实现原理&lt;/a&gt; 大头鬼Bruce&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;热修复库&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dodola/HotFix&quot;&gt;https://github.com/dodola/HotFix&lt;/a&gt; dodola&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jasonross/Nuwa&quot;&gt;https://github.com/jasonross/Nuwa&lt;/a&gt; 寒江不钓&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/bunnyblue/DroidFix&quot;&gt;https://github.com/bunnyblue/DroidFix&lt;/a&gt; BunnyBlue&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://maoruibin.github.io//technology/2015/11/17/Android-hotfix.html</link>
        <guid isPermaLink="true">http://maoruibin.github.io//technology/2015/11/17/Android-hotfix.html</guid>
        
        <category>Android</category>
        
        <category>HotFix</category>
        
        <category>Collection</category>
        
        
        <category>technology</category>
        
      </item>
    
  </channel>
</rss>
